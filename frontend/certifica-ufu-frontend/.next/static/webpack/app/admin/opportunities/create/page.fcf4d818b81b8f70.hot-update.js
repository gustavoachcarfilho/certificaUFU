"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/opportunities/create/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyToOpportunity: () => (/* binding */ applyToOpportunity),\n/* harmony export */   createCertificate: () => (/* binding */ createCertificate),\n/* harmony export */   createOpportunity: () => (/* binding */ createOpportunity),\n/* harmony export */   getAllOpportunities: () => (/* binding */ getAllOpportunities),\n/* harmony export */   getCertificateViewUrl: () => (/* binding */ getCertificateViewUrl),\n/* harmony export */   getMyCertificates: () => (/* binding */ getMyCertificates),\n/* harmony export */   getPendingCertificates: () => (/* binding */ getPendingCertificates),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   validateCertificate: () => (/* binding */ validateCertificate)\n/* harmony export */ });\n// This file will centralize all API calls.\n// The base URL of your Spring Boot backend API.\nconst API_URL = 'http://localhost:8080';\n/**\r\n * Performs a login request to the backend.\r\n * @param email - The user's email.\r\n * @param password - The user's password.\r\n * @returns A promise that resolves with the login response data.\r\n */ const login = async (email, password)=>{\n    const response = await fetch(\"\".concat(API_URL, \"/auth/login\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            email,\n            password\n        })\n    });\n    if (!response.ok) {\n        // Throws an error if the server response is not successful.\n        throw new Error('Falha no login. Verifique suas credenciais.');\n    }\n    // Parses the JSON response from the server.\n    return response.json();\n};\nconst applyToOpportunity = async (opportunityId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity/\").concat(opportunityId, \"/apply\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao se candidatar à oportunidade.');\n    }\n    return response.json();\n};\nconst validateCertificate = async (certificateId, status, rejectionReason)=>{\n    const token = localStorage.getItem('authToken');\n    const body = {\n        status,\n        rejectionReason\n    };\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/validate\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(body)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao validar o certificado.');\n    }\n    return response.json();\n};\nconst getPendingCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar certificados.');\n    }\n    const allCerts = await response.json();\n    // Filter for pending certificates on the client-side for now\n    return allCerts.filter((cert)=>cert.status === 'PENDING');\n};\nconst createCertificate = async (certificateData, file)=>{\n    const token = localStorage.getItem('authToken');\n    // FormData is used to send files and data together.\n    const formData = new FormData();\n    // The backend expects a JSON part named \"request\". We must create a Blob for it.\n    formData.append('request', new Blob([\n        JSON.stringify(certificateData)\n    ], {\n        type: 'application/json'\n    }));\n    // The backend expects a file part named \"file\".\n    formData.append('file', file);\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'POST',\n        headers: {\n            // For multipart/form-data, we don't set Content-Type. The browser does it automatically.\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: formData\n    });\n    if (!response.ok) {\n        // Attempt to get more detailed error info from the response body\n        const errorData = await response.json().catch(()=>({\n                message: 'Falha ao criar o certificado.'\n            }));\n        throw new Error(errorData.message || 'Falha ao criar o certificado.');\n    }\n    return response.json();\n};\nconst getMyCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/my-documents\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar os documentos.');\n    }\n    return response.json();\n};\nconst createOpportunity = async (opportunityData)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(opportunityData)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao criar a oportunidade.');\n    }\n    return response.json();\n};\nconst getAllOpportunities = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar as oportunidades.');\n    }\n    return response.json();\n};\nconst getCertificateViewUrl = async (certificateId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/view-url\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao obter a URL do documento.');\n    }\n    const data = await response.json();\n    return data.url; // A API retorna { \"url\": \"...\" }\n};\nconst registerUser = async (userData)=>{\n    // Agora a função simplesmente envia os dados que recebe, incluindo a role.\n    const response = await fetch(\"\".concat(API_URL, \"/auth/register\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(userData)\n    });\n    if (!response.ok) {\n        if (response.status === 400) {\n            throw new Error('Email ou CPF já cadastrado.');\n        }\n        throw new Error('Falha ao tentar realizar o cadastro.');\n    }\n    return;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDUCxpQkFBaUIsVUFBZ0IsT0FBTlM7UUFDN0I7SUFDRjtJQUVBLElBQUksQ0FBQ1osU0FBU08sRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLE9BQU9SLFNBQVNTLElBQUk7QUFDdEIsRUFBRTtBQUVLLE1BQU02Qix3QkFBd0IsT0FBT3RCO0lBQzFDLE1BQU1KLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztJQUVuQyxNQUFNZCxXQUFXLE1BQU1DLE1BQU0sR0FBMEJlLE9BQXZCcEIsU0FBUSxpQkFBNkIsT0FBZG9CLGVBQWMsY0FBWTtRQUMvRWQsUUFBUTtRQUNSQyxTQUFTO1lBQ1AsaUJBQWlCLFVBQWdCLE9BQU5TO1FBQzdCO0lBQ0Y7SUFFQSxJQUFJLENBQUNaLFNBQVNPLEVBQUUsRUFBRTtRQUNoQixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNK0IsT0FBTyxNQUFNdkMsU0FBU1MsSUFBSTtJQUNoQyxPQUFPOEIsS0FBS0MsR0FBRyxFQUFFLGlDQUFpQztBQUNwRCxFQUFFO0FBRUssTUFBTUMsZUFBZSxPQUFPQztJQUNqQywyRUFBMkU7SUFDM0UsTUFBTTFDLFdBQVcsTUFBTUMsTUFBTSxHQUFXLE9BQVJMLFNBQVEsbUJBQWlCO1FBQ3ZETSxRQUFRO1FBQ1JDLFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7UUFDQUMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDb0M7SUFDdkI7SUFFQSxJQUFJLENBQUMxQyxTQUFTTyxFQUFFLEVBQUU7UUFDaEIsSUFBSVAsU0FBU2lCLE1BQU0sS0FBSyxLQUFLO1lBQzNCLE1BQU0sSUFBSVQsTUFBTTtRQUNsQjtRQUNBLE1BQU0sSUFBSUEsTUFBTTtJQUNsQjtJQUVBO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxHdXN0YXZvIEFjaGNhciBGaWxob1xcRGVza3RvcFxccHJvamVjdHNcXENlcnRpZmljYSBVRlUgLSBQRFNJMVxcY2VydGlmaWNhVUZVXFxmcm9udGVuZFxcY2VydGlmaWNhLXVmdS1mcm9udGVuZFxcbGliXFxhcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdpbGwgY2VudHJhbGl6ZSBhbGwgQVBJIGNhbGxzLlxyXG5cclxuLy8gVGhlIGJhc2UgVVJMIG9mIHlvdXIgU3ByaW5nIEJvb3QgYmFja2VuZCBBUEkuXHJcbmNvbnN0IEFQSV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDgwJztcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxvZ2luIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwuXHJcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvZ2luIHJlc3BvbnNlIGRhdGEuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6YW55LCBwYXNzd29yZDphbnkpID0+IHtcclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2F1dGgvbG9naW5gLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICB9KTtcclxuXHJcbiAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgbm90IHN1Y2Nlc3NmdWwuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIG5vIGxvZ2luLiBWZXJpZmlxdWUgc3VhcyBjcmVkZW5jaWFpcy4nKTtcclxuICB9XHJcblxyXG4gIC8vIFBhcnNlcyB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhcHBseVRvT3Bwb3J0dW5pdHkgPSBhc3luYyAob3Bwb3J0dW5pdHlJZDogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vb3Bwb3J0dW5pdHkvJHtvcHBvcnR1bml0eUlkfS9hcHBseWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsIC8vIFNlbmRpbmcgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBzZSBjYW5kaWRhdGFyIMOgIG9wb3J0dW5pZGFkZS4nKTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IHZhbGlkYXRlQ2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nLCBzdGF0dXM6ICdBUFBST1ZFRCcgfCAnREVOSUVEJywgcmVqZWN0aW9uUmVhc29uPzogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgIGNvbnN0IGJvZHkgPSB7XHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgcmVqZWN0aW9uUmVhc29uLFxyXG4gICAgfTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vY2VydGlmaWNhdGUvJHtjZXJ0aWZpY2F0ZUlkfS92YWxpZGF0ZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gdmFsaWRhciBvIGNlcnRpZmljYWRvLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9O1xyXG4gIFxyXG4gIGV4cG9ydCBjb25zdCBnZXRQZW5kaW5nQ2VydGlmaWNhdGVzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9jZXJ0aWZpY2F0ZWAsIHsgLy8gQXNzdW1pbmcgR0VUIC9jZXJ0aWZpY2F0ZSByZXR1cm5zIGFsbFxyXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gYnVzY2FyIGNlcnRpZmljYWRvcy4nKTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICBjb25zdCBhbGxDZXJ0cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgLy8gRmlsdGVyIGZvciBwZW5kaW5nIGNlcnRpZmljYXRlcyBvbiB0aGUgY2xpZW50LXNpZGUgZm9yIG5vd1xyXG4gICAgICByZXR1cm4gYWxsQ2VydHMuZmlsdGVyKGNlcnQgPT4gY2VydC5zdGF0dXMgPT09ICdQRU5ESU5HJyk7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGNyZWF0ZUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlRGF0YTogb2JqZWN0LCBmaWxlOiBGaWxlKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgIFxyXG4gICAgLy8gRm9ybURhdGEgaXMgdXNlZCB0byBzZW5kIGZpbGVzIGFuZCBkYXRhIHRvZ2V0aGVyLlxyXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgIFxyXG4gICAgLy8gVGhlIGJhY2tlbmQgZXhwZWN0cyBhIEpTT04gcGFydCBuYW1lZCBcInJlcXVlc3RcIi4gV2UgbXVzdCBjcmVhdGUgYSBCbG9iIGZvciBpdC5cclxuICAgIGZvcm1EYXRhLmFwcGVuZCgncmVxdWVzdCcsIG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShjZXJ0aWZpY2F0ZURhdGEpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSkpO1xyXG4gICAgXHJcbiAgICAvLyBUaGUgYmFja2VuZCBleHBlY3RzIGEgZmlsZSBwYXJ0IG5hbWVkIFwiZmlsZVwiLlxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2NlcnRpZmljYXRlYCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIC8vIEZvciBtdWx0aXBhcnQvZm9ybS1kYXRhLCB3ZSBkb24ndCBzZXQgQ29udGVudC1UeXBlLiBUaGUgYnJvd3NlciBkb2VzIGl0IGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogZm9ybURhdGEsXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgbW9yZSBkZXRhaWxlZCBlcnJvciBpbmZvIGZyb20gdGhlIHJlc3BvbnNlIGJvZHlcclxuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6ICdGYWxoYSBhbyBjcmlhciBvIGNlcnRpZmljYWRvLicgfSkpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgJ0ZhbGhhIGFvIGNyaWFyIG8gY2VydGlmaWNhZG8uJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCBnZXRNeUNlcnRpZmljYXRlcyA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9jZXJ0aWZpY2F0ZS9teS1kb2N1bWVudHNgLCB7XHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gYnVzY2FyIG9zIGRvY3VtZW50b3MuJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCBjcmVhdGVPcHBvcnR1bml0eSA9IGFzeW5jIChvcHBvcnR1bml0eURhdGE6IG9iamVjdCkgPT4ge1xyXG4gIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L29wcG9ydHVuaXR5YCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3Bwb3J0dW5pdHlEYXRhKSxcclxuICB9KTtcclxuXHJcbiAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBjcmlhciBhIG9wb3J0dW5pZGFkZS4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxsT3Bwb3J0dW5pdGllcyA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9vcHBvcnR1bml0eWAsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBidXNjYXIgYXMgb3BvcnR1bmlkYWRlcy4nKTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGdldENlcnRpZmljYXRlVmlld1VybCA9IGFzeW5jIChjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9jZXJ0aWZpY2F0ZS8ke2NlcnRpZmljYXRlSWR9L3ZpZXctdXJsYCwge1xyXG4gICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIG9idGVyIGEgVVJMIGRvIGRvY3VtZW50by4nKTtcclxuICAgIH1cclxuICBcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXR1cm4gZGF0YS51cmw7IC8vIEEgQVBJIHJldG9ybmEgeyBcInVybFwiOiBcIi4uLlwiIH1cclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHVzZXJEYXRhOiBvYmplY3QpID0+IHtcclxuICAgIC8vIEFnb3JhIGEgZnVuw6fDo28gc2ltcGxlc21lbnRlIGVudmlhIG9zIGRhZG9zIHF1ZSByZWNlYmUsIGluY2x1aW5kbyBhIHJvbGUuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2F1dGgvcmVnaXN0ZXJgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1haWwgb3UgQ1BGIGrDoSBjYWRhc3RyYWRvLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gdGVudGFyIHJlYWxpemFyIG8gY2FkYXN0cm8uJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm47XHJcbiAgfTsiXSwibmFtZXMiOlsiQVBJX1VSTCIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwianNvbiIsImFwcGx5VG9PcHBvcnR1bml0eSIsIm9wcG9ydHVuaXR5SWQiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ2YWxpZGF0ZUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsInN0YXR1cyIsInJlamVjdGlvblJlYXNvbiIsImdldFBlbmRpbmdDZXJ0aWZpY2F0ZXMiLCJhbGxDZXJ0cyIsImZpbHRlciIsImNlcnQiLCJjcmVhdGVDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlRGF0YSIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiQmxvYiIsInR5cGUiLCJlcnJvckRhdGEiLCJjYXRjaCIsIm1lc3NhZ2UiLCJnZXRNeUNlcnRpZmljYXRlcyIsImNyZWF0ZU9wcG9ydHVuaXR5Iiwib3Bwb3J0dW5pdHlEYXRhIiwiZ2V0QWxsT3Bwb3J0dW5pdGllcyIsImdldENlcnRpZmljYXRlVmlld1VybCIsImRhdGEiLCJ1cmwiLCJyZWdpc3RlclVzZXIiLCJ1c2VyRGF0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});