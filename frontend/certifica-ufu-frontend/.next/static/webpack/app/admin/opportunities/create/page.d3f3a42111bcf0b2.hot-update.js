"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/opportunities/create/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyToOpportunity: () => (/* binding */ applyToOpportunity),\n/* harmony export */   createCertificate: () => (/* binding */ createCertificate),\n/* harmony export */   createOpportunity: () => (/* binding */ createOpportunity),\n/* harmony export */   getAllOpportunities: () => (/* binding */ getAllOpportunities),\n/* harmony export */   getCertificateViewUrl: () => (/* binding */ getCertificateViewUrl),\n/* harmony export */   getMyCertificates: () => (/* binding */ getMyCertificates),\n/* harmony export */   getPendingCertificates: () => (/* binding */ getPendingCertificates),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   validateCertificate: () => (/* binding */ validateCertificate)\n/* harmony export */ });\n// This file will centralize all API calls.\n// The base URL of your Spring Boot backend API.\nconst API_URL = 'http://localhost:8080';\n/**\r\n * Performs a login request to the backend.\r\n * @param email - The user's email.\r\n * @param password - The user's password.\r\n * @returns A promise that resolves with the login response data.\r\n */ const login = async (email, password)=>{\n    const response = await fetch(\"\".concat(API_URL, \"/auth/login\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            email,\n            password\n        })\n    });\n    if (!response.ok) {\n        // Throws an error if the server response is not successful.\n        throw new Error('Falha no login. Verifique suas credenciais.');\n    }\n    // Parses the JSON response from the server.\n    return response.json();\n};\nconst applyToOpportunity = async (opportunityId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity/\").concat(opportunityId, \"/apply\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao se candidatar à oportunidade.');\n    }\n    return response.json();\n};\nconst validateCertificate = async (certificateId, status, rejectionReason)=>{\n    const token = localStorage.getItem('authToken');\n    const body = {\n        status,\n        rejectionReason\n    };\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/validate\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(body)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao validar o certificado.');\n    }\n    return response.json();\n};\nconst getPendingCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar certificados.');\n    }\n    const allCerts = await response.json();\n    // Filter for pending certificates on the client-side for now\n    return allCerts.filter((cert)=>cert.status === 'PENDING');\n};\nconst createCertificate = async (certificateData, file)=>{\n    const token = localStorage.getItem('authToken');\n    // FormData is used to send files and data together.\n    const formData = new FormData();\n    // The backend expects a JSON part named \"request\". We must create a Blob for it.\n    formData.append('request', new Blob([\n        JSON.stringify(certificateData)\n    ], {\n        type: 'application/json'\n    }));\n    // The backend expects a file part named \"file\".\n    formData.append('file', file);\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'POST',\n        headers: {\n            // For multipart/form-data, we don't set Content-Type. The browser does it automatically.\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: formData\n    });\n    if (!response.ok) {\n        // Attempt to get more detailed error info from the response body\n        const errorData = await response.json().catch(()=>({\n                message: 'Falha ao criar o certificado.'\n            }));\n        throw new Error(errorData.message || 'Falha ao criar o certificado.');\n    }\n    return response.json();\n};\nconst getMyCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/my-documents\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar os documentos.');\n    }\n    return response.json();\n};\nconst createOpportunity = async (opportunityData)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(opportunityData)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao criar a oportunidade.');\n    }\n    return response.json();\n};\nconst getAllOpportunities = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar as oportunidades.');\n    }\n    return response.json();\n};\nconst getCertificateViewUrl = async (certificateId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/view-url\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao obter a URL do documento.');\n    }\n    const data = await response.json();\n    return data.url; // A API retorna { \"url\": \"...\" }\n};\nconst registerUser = async (userData)=>{\n    // Para o registro, o papel (role) será 'USER' por padrão\n    const registrationData = {\n        ...userData,\n        role: 'USER'\n    };\n    const response = await fetch(\"\".concat(API_URL, \"/auth/register\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(registrationData)\n    });\n    if (!response.ok) {\n        // O backend retorna 400 Bad Request se o email/CPF já existir\n        if (response.status === 400) {\n            throw new Error('Email ou CPF já cadastrado.');\n        }\n        throw new Error('Falha ao tentar realizar o cadastro.');\n    }\n    // A API de registro não retorna um corpo, então não precisamos do .json()\n    return;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c1xcQ2VydGlmaWNhIFVGVSAtIFBEU0kxXFxjZXJ0aWZpY2FVRlVcXGZyb250ZW5kXFxjZXJ0aWZpY2EtdWZ1LWZyb250ZW5kXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgd2lsbCBjZW50cmFsaXplIGFsbCBBUEkgY2FsbHMuXHJcblxyXG4vLyBUaGUgYmFzZSBVUkwgb2YgeW91ciBTcHJpbmcgQm9vdCBiYWNrZW5kIEFQSS5cclxuY29uc3QgQVBJX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0OjgwODAnO1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbG9naW4gcmVxdWVzdCB0byB0aGUgYmFja2VuZC5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbC5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9naW4gcmVzcG9uc2UgZGF0YS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbDphbnksIHBhc3N3b3JkOmFueSkgPT4ge1xyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXV0aC9sb2dpbmAsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxyXG4gIH0pO1xyXG5cclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNlcnZlciByZXNwb25zZSBpcyBub3Qgc3VjY2Vzc2Z1bC5cclxuICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgbm8gbG9naW4uIFZlcmlmaXF1ZSBzdWFzIGNyZWRlbmNpYWlzLicpO1xyXG4gIH1cclxuXHJcbiAgLy8gUGFyc2VzIHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cclxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGx5VG9PcHBvcnR1bml0eSA9IGFzeW5jIChvcHBvcnR1bml0eUlkOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9vcHBvcnR1bml0eS8ke29wcG9ydHVuaXR5SWR9L2FwcGx5YCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCwgLy8gU2VuZGluZyB0aGUgYXV0aGVudGljYXRpb24gdG9rZW5cclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIHNlIGNhbmRpZGF0YXIgw6Agb3BvcnR1bmlkYWRlLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgdmFsaWRhdGVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcsIHN0YXR1czogJ0FQUFJPVkVEJyB8ICdERU5JRUQnLCByZWplY3Rpb25SZWFzb24/OiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgY29uc3QgYm9keSA9IHtcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICByZWplY3Rpb25SZWFzb24sXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9jZXJ0aWZpY2F0ZS8ke2NlcnRpZmljYXRlSWR9L3ZhbGlkYXRlYCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyB2YWxpZGFyIG8gY2VydGlmaWNhZG8uJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH07XHJcbiAgXHJcbiAgZXhwb3J0IGNvbnN0IGdldFBlbmRpbmdDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2NlcnRpZmljYXRlYCwgeyAvLyBBc3N1bWluZyBHRVQgL2NlcnRpZmljYXRlIHJldHVybnMgYWxsXHJcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBidXNjYXIgY2VydGlmaWNhZG9zLicpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGNvbnN0IGFsbENlcnRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAvLyBGaWx0ZXIgZm9yIHBlbmRpbmcgY2VydGlmaWNhdGVzIG9uIHRoZSBjbGllbnQtc2lkZSBmb3Igbm93XHJcbiAgICAgIHJldHVybiBhbGxDZXJ0cy5maWx0ZXIoY2VydCA9PiBjZXJ0LnN0YXR1cyA9PT0gJ1BFTkRJTkcnKTtcclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgY3JlYXRlQ2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVEYXRhOiBvYmplY3QsIGZpbGU6IEZpbGUpID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgXHJcbiAgICAvLyBGb3JtRGF0YSBpcyB1c2VkIHRvIHNlbmQgZmlsZXMgYW5kIGRhdGEgdG9nZXRoZXIuXHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgXHJcbiAgICAvLyBUaGUgYmFja2VuZCBleHBlY3RzIGEgSlNPTiBwYXJ0IG5hbWVkIFwicmVxdWVzdFwiLiBXZSBtdXN0IGNyZWF0ZSBhIEJsb2IgZm9yIGl0LlxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCdyZXF1ZXN0JywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGNlcnRpZmljYXRlRGF0YSldLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSk7XHJcbiAgICBcclxuICAgIC8vIFRoZSBiYWNrZW5kIGV4cGVjdHMgYSBmaWxlIHBhcnQgbmFtZWQgXCJmaWxlXCIuXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vY2VydGlmaWNhdGVgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgLy8gRm9yIG11bHRpcGFydC9mb3JtLWRhdGEsIHdlIGRvbid0IHNldCBDb250ZW50LVR5cGUuIFRoZSBicm93c2VyIGRvZXMgaXQgYXV0b21hdGljYWxseS5cclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAvLyBBdHRlbXB0IHRvIGdldCBtb3JlIGRldGFpbGVkIGVycm9yIGluZm8gZnJvbSB0aGUgcmVzcG9uc2UgYm9keVxyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgbWVzc2FnZTogJ0ZhbGhhIGFvIGNyaWFyIG8gY2VydGlmaWNhZG8uJyB9KSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCAnRmFsaGEgYW8gY3JpYXIgbyBjZXJ0aWZpY2Fkby4nKTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGdldE15Q2VydGlmaWNhdGVzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2NlcnRpZmljYXRlL215LWRvY3VtZW50c2AsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBidXNjYXIgb3MgZG9jdW1lbnRvcy4nKTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGNyZWF0ZU9wcG9ydHVuaXR5ID0gYXN5bmMgKG9wcG9ydHVuaXR5RGF0YTogb2JqZWN0KSA9PiB7XHJcbiAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vb3Bwb3J0dW5pdHlgLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHBvcnR1bml0eURhdGEpLFxyXG4gIH0pO1xyXG5cclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIGNyaWFyIGEgb3BvcnR1bmlkYWRlLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxPcHBvcnR1bml0aWVzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L29wcG9ydHVuaXR5YCwge1xyXG4gICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIGJ1c2NhciBhcyBvcG9ydHVuaWRhZGVzLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgZ2V0Q2VydGlmaWNhdGVWaWV3VXJsID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2NlcnRpZmljYXRlLyR7Y2VydGlmaWNhdGVJZH0vdmlldy11cmxgLCB7XHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gb2J0ZXIgYSBVUkwgZG8gZG9jdW1lbnRvLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIHJldHVybiBkYXRhLnVybDsgLy8gQSBBUEkgcmV0b3JuYSB7IFwidXJsXCI6IFwiLi4uXCIgfVxyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAodXNlckRhdGE6IG9iamVjdCkgPT4ge1xyXG4gICAgLy8gUGFyYSBvIHJlZ2lzdHJvLCBvIHBhcGVsIChyb2xlKSBzZXLDoSAnVVNFUicgcG9yIHBhZHLDo29cclxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbkRhdGEgPSB7XHJcbiAgICAgIC4uLnVzZXJEYXRhLFxyXG4gICAgICByb2xlOiAnVVNFUidcclxuICAgIH07XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2F1dGgvcmVnaXN0ZXJgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVnaXN0cmF0aW9uRGF0YSksXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgLy8gTyBiYWNrZW5kIHJldG9ybmEgNDAwIEJhZCBSZXF1ZXN0IHNlIG8gZW1haWwvQ1BGIGrDoSBleGlzdGlyXHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1haWwgb3UgQ1BGIGrDoSBjYWRhc3RyYWRvLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gdGVudGFyIHJlYWxpemFyIG8gY2FkYXN0cm8uJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBBIEFQSSBkZSByZWdpc3RybyBuw6NvIHJldG9ybmEgdW0gY29ycG8sIGVudMOjbyBuw6NvIHByZWNpc2Ftb3MgZG8gLmpzb24oKVxyXG4gICAgcmV0dXJuO1xyXG4gIH07Il0sIm5hbWVzIjpbIkFQSV9VUkwiLCJsb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsImpzb24iLCJhcHBseVRvT3Bwb3J0dW5pdHkiLCJvcHBvcnR1bml0eUlkIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidmFsaWRhdGVDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJzdGF0dXMiLCJyZWplY3Rpb25SZWFzb24iLCJnZXRQZW5kaW5nQ2VydGlmaWNhdGVzIiwiYWxsQ2VydHMiLCJmaWx0ZXIiLCJjZXJ0IiwiY3JlYXRlQ2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZURhdGEiLCJmaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsIkJsb2IiLCJ0eXBlIiwiZXJyb3JEYXRhIiwiY2F0Y2giLCJtZXNzYWdlIiwiZ2V0TXlDZXJ0aWZpY2F0ZXMiLCJjcmVhdGVPcHBvcnR1bml0eSIsIm9wcG9ydHVuaXR5RGF0YSIsImdldEFsbE9wcG9ydHVuaXRpZXMiLCJnZXRDZXJ0aWZpY2F0ZVZpZXdVcmwiLCJkYXRhIiwidXJsIiwicmVnaXN0ZXJVc2VyIiwidXNlckRhdGEiLCJyZWdpc3RyYXRpb25EYXRhIiwicm9sZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});