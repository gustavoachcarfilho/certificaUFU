"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/student/opportunities/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyToOpportunity: () => (/* binding */ applyToOpportunity),\n/* harmony export */   createCertificate: () => (/* binding */ createCertificate),\n/* harmony export */   createOpportunity: () => (/* binding */ createOpportunity),\n/* harmony export */   getAllOpportunities: () => (/* binding */ getAllOpportunities),\n/* harmony export */   getCertificateViewUrl: () => (/* binding */ getCertificateViewUrl),\n/* harmony export */   getMyCertificates: () => (/* binding */ getMyCertificates),\n/* harmony export */   getPendingCertificates: () => (/* binding */ getPendingCertificates),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   validateCertificate: () => (/* binding */ validateCertificate)\n/* harmony export */ });\n// This file will centralize all API calls.\n// The base URL of your Spring Boot backend API.\nconst API_URL = 'http://localhost:8080';\n/**\r\n * Performs a login request to the backend.\r\n * @param email - The user's email.\r\n * @param password - The user's password.\r\n * @returns A promise that resolves with the login response data.\r\n */ const login = async (email, password)=>{\n    const response = await fetch(\"\".concat(API_URL, \"/auth/login\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            email,\n            password\n        })\n    });\n    if (!response.ok) {\n        // Throws an error if the server response is not successful.\n        throw new Error('Falha no login. Verifique suas credenciais.');\n    }\n    // Parses the JSON response from the server.\n    return response.json();\n};\nconst applyToOpportunity = async (opportunityId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity/\").concat(opportunityId, \"/apply\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao se candidatar Ã  oportunidade.');\n    }\n    return response.json();\n};\nconst validateCertificate = async (certificateId, status, rejectionReason)=>{\n    const token = localStorage.getItem('authToken');\n    const body = {\n        status,\n        rejectionReason\n    };\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/validate\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(body)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao validar o certificado.');\n    }\n    return response.json();\n};\nconst getPendingCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar certificados.');\n    }\n    const allCerts = await response.json();\n    // Filter for pending certificates on the client-side for now\n    return allCerts.filter((cert)=>cert.status === 'PENDING');\n};\nconst createCertificate = async (certificateData, file)=>{\n    const token = localStorage.getItem('authToken');\n    // FormData is used to send files and data together.\n    const formData = new FormData();\n    // The backend expects a JSON part named \"request\". We must create a Blob for it.\n    formData.append('request', new Blob([\n        JSON.stringify(certificateData)\n    ], {\n        type: 'application/json'\n    }));\n    // The backend expects a file part named \"file\".\n    formData.append('file', file);\n    const response = await fetch(\"\".concat(API_URL, \"/certificate\"), {\n        method: 'POST',\n        headers: {\n            // For multipart/form-data, we don't set Content-Type. The browser does it automatically.\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: formData\n    });\n    if (!response.ok) {\n        // Attempt to get more detailed error info from the response body\n        const errorData = await response.json().catch(()=>({\n                message: 'Falha ao criar o certificado.'\n            }));\n        throw new Error(errorData.message || 'Falha ao criar o certificado.');\n    }\n    return response.json();\n};\nconst getMyCertificates = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/my-documents\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar os documentos.');\n    }\n    return response.json();\n};\nconst createOpportunity = async (opportunityData)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': \"Bearer \".concat(token)\n        },\n        body: JSON.stringify(opportunityData)\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao criar a oportunidade.');\n    }\n    return response.json();\n};\nconst getAllOpportunities = async ()=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/opportunity\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao buscar as oportunidades.');\n    }\n    return response.json();\n};\nconst getCertificateViewUrl = async (certificateId)=>{\n    const token = localStorage.getItem('authToken');\n    const response = await fetch(\"\".concat(API_URL, \"/certificate/\").concat(certificateId, \"/view-url\"), {\n        method: 'GET',\n        headers: {\n            'Authorization': \"Bearer \".concat(token)\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Falha ao obter a URL do documento.');\n    }\n    const data = await response.json();\n    return data.url; // A API retorna { \"url\": \"...\" }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNQLGlCQUFpQixVQUFnQixPQUFOUztRQUM3QjtJQUNGO0lBRUEsSUFBSSxDQUFDWixTQUFTTyxFQUFFLEVBQUU7UUFDaEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsT0FBT1IsU0FBU1MsSUFBSTtBQUN0QixFQUFFO0FBRUssTUFBTTZCLHdCQUF3QixPQUFPdEI7SUFDMUMsTUFBTUosUUFBUUMsYUFBYUMsT0FBTyxDQUFDO0lBRW5DLE1BQU1kLFdBQVcsTUFBTUMsTUFBTSxHQUEwQmUsT0FBdkJwQixTQUFRLGlCQUE2QixPQUFkb0IsZUFBYyxjQUFZO1FBQy9FZCxRQUFRO1FBQ1JDLFNBQVM7WUFDUCxpQkFBaUIsVUFBZ0IsT0FBTlM7UUFDN0I7SUFDRjtJQUVBLElBQUksQ0FBQ1osU0FBU08sRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLE1BQU0rQixPQUFPLE1BQU12QyxTQUFTUyxJQUFJO0lBQ2hDLE9BQU84QixLQUFLQyxHQUFHLEVBQUUsaUNBQWlDO0FBQ3BELEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcR3VzdGF2byBBY2hjYXIgRmlsaG9cXERlc2t0b3BcXHByb2plY3RzXFxDZXJ0aWZpY2EgVUZVIC0gUERTSTFcXGNlcnRpZmljYVVGVVxcZnJvbnRlbmRcXGNlcnRpZmljYS11ZnUtZnJvbnRlbmRcXGxpYlxcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSB3aWxsIGNlbnRyYWxpemUgYWxsIEFQSSBjYWxscy5cclxuXHJcbi8vIFRoZSBiYXNlIFVSTCBvZiB5b3VyIFNwcmluZyBCb290IGJhY2tlbmQgQVBJLlxyXG5jb25zdCBBUElfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCc7XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYSBsb2dpbiByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLlxyXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsLlxyXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2dpbiByZXNwb25zZSBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOmFueSwgcGFzc3dvcmQ6YW55KSA9PiB7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hdXRoL2xvZ2luYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXHJcbiAgfSk7XHJcblxyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIG5vdCBzdWNjZXNzZnVsLlxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBubyBsb2dpbi4gVmVyaWZpcXVlIHN1YXMgY3JlZGVuY2lhaXMuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBQYXJzZXMgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxyXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXBwbHlUb09wcG9ydHVuaXR5ID0gYXN5bmMgKG9wcG9ydHVuaXR5SWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L29wcG9ydHVuaXR5LyR7b3Bwb3J0dW5pdHlJZH0vYXBwbHlgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLCAvLyBTZW5kaW5nIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gc2UgY2FuZGlkYXRhciDDoCBvcG9ydHVuaWRhZGUuJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCB2YWxpZGF0ZUNlcnRpZmljYXRlID0gYXN5bmMgKGNlcnRpZmljYXRlSWQ6IHN0cmluZywgc3RhdHVzOiAnQVBQUk9WRUQnIHwgJ0RFTklFRCcsIHJlamVjdGlvblJlYXNvbj86IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICBjb25zdCBib2R5ID0ge1xyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHJlamVjdGlvblJlYXNvbixcclxuICAgIH07XHJcbiAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2NlcnRpZmljYXRlLyR7Y2VydGlmaWNhdGVJZH0vdmFsaWRhdGVgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIHZhbGlkYXIgbyBjZXJ0aWZpY2Fkby4nKTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfTtcclxuICBcclxuICBleHBvcnQgY29uc3QgZ2V0UGVuZGluZ0NlcnRpZmljYXRlcyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vY2VydGlmaWNhdGVgLCB7IC8vIEFzc3VtaW5nIEdFVCAvY2VydGlmaWNhdGUgcmV0dXJucyBhbGxcclxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIGJ1c2NhciBjZXJ0aWZpY2Fkb3MuJyk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgY29uc3QgYWxsQ2VydHMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIC8vIEZpbHRlciBmb3IgcGVuZGluZyBjZXJ0aWZpY2F0ZXMgb24gdGhlIGNsaWVudC1zaWRlIGZvciBub3dcclxuICAgICAgcmV0dXJuIGFsbENlcnRzLmZpbHRlcihjZXJ0ID0+IGNlcnQuc3RhdHVzID09PSAnUEVORElORycpO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCBjcmVhdGVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZURhdGE6IG9iamVjdCwgZmlsZTogRmlsZSkgPT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICBcclxuICAgIC8vIEZvcm1EYXRhIGlzIHVzZWQgdG8gc2VuZCBmaWxlcyBhbmQgZGF0YSB0b2dldGhlci5cclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICBcclxuICAgIC8vIFRoZSBiYWNrZW5kIGV4cGVjdHMgYSBKU09OIHBhcnQgbmFtZWQgXCJyZXF1ZXN0XCIuIFdlIG11c3QgY3JlYXRlIGEgQmxvYiBmb3IgaXQuXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3JlcXVlc3QnLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoY2VydGlmaWNhdGVEYXRhKV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pKTtcclxuICAgIFxyXG4gICAgLy8gVGhlIGJhY2tlbmQgZXhwZWN0cyBhIGZpbGUgcGFydCBuYW1lZCBcImZpbGVcIi5cclxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xyXG4gIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9jZXJ0aWZpY2F0ZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAvLyBGb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSwgd2UgZG9uJ3Qgc2V0IENvbnRlbnQtVHlwZS4gVGhlIGJyb3dzZXIgZG9lcyBpdCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IG1vcmUgZGV0YWlsZWQgZXJyb3IgaW5mbyBmcm9tIHRoZSByZXNwb25zZSBib2R5XHJcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiAnRmFsaGEgYW8gY3JpYXIgbyBjZXJ0aWZpY2Fkby4nIH0pKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWxoYSBhbyBjcmlhciBvIGNlcnRpZmljYWRvLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgZ2V0TXlDZXJ0aWZpY2F0ZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vY2VydGlmaWNhdGUvbXktZG9jdW1lbnRzYCwge1xyXG4gICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGhhIGFvIGJ1c2NhciBvcyBkb2N1bWVudG9zLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9O1xyXG5cclxuICBleHBvcnQgY29uc3QgY3JlYXRlT3Bwb3J0dW5pdHkgPSBhc3luYyAob3Bwb3J0dW5pdHlEYXRhOiBvYmplY3QpID0+IHtcclxuICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9vcHBvcnR1bml0eWAsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wcG9ydHVuaXR5RGF0YSksXHJcbiAgfSk7XHJcblxyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gY3JpYXIgYSBvcG9ydHVuaWRhZGUuJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEFsbE9wcG9ydHVuaXRpZXMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vb3Bwb3J0dW5pdHlgLCB7XHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gYnVzY2FyIGFzIG9wb3J0dW5pZGFkZXMuJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydCBjb25zdCBnZXRDZXJ0aWZpY2F0ZVZpZXdVcmwgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcclxuICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vY2VydGlmaWNhdGUvJHtjZXJ0aWZpY2F0ZUlkfS92aWV3LXVybGAsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBvYnRlciBhIFVSTCBkbyBkb2N1bWVudG8uJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgcmV0dXJuIGRhdGEudXJsOyAvLyBBIEFQSSByZXRvcm5hIHsgXCJ1cmxcIjogXCIuLi5cIiB9XHJcbiAgfTsiXSwibmFtZXMiOlsiQVBJX1VSTCIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwianNvbiIsImFwcGx5VG9PcHBvcnR1bml0eSIsIm9wcG9ydHVuaXR5SWQiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ2YWxpZGF0ZUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsInN0YXR1cyIsInJlamVjdGlvblJlYXNvbiIsImdldFBlbmRpbmdDZXJ0aWZpY2F0ZXMiLCJhbGxDZXJ0cyIsImZpbHRlciIsImNlcnQiLCJjcmVhdGVDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlRGF0YSIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiQmxvYiIsInR5cGUiLCJlcnJvckRhdGEiLCJjYXRjaCIsIm1lc3NhZ2UiLCJnZXRNeUNlcnRpZmljYXRlcyIsImNyZWF0ZU9wcG9ydHVuaXR5Iiwib3Bwb3J0dW5pdHlEYXRhIiwiZ2V0QWxsT3Bwb3J0dW5pdGllcyIsImdldENlcnRpZmljYXRlVmlld1VybCIsImRhdGEiLCJ1cmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});